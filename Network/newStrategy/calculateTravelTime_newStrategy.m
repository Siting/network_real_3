function[travelTime_values] = calculateTravelTime_newStrategy(ACCEPTED_POP, linkMap, sensorMetaDataMap)

travelTime_values = zeros(size(ACCEPTED_POP(1).samples,2),4);

% calculate for t1 and t2
travelTime_values(:,1) = linkMap(1).lengthInMiles ./ ACCEPTED_POP(1).samples(1,:) + ...
    linkMap(3).lengthInMiles ./ ACCEPTED_POP(3).samples(1,:) + ...
    sensorMetaDataMap(400739).offsetMiles ./ ACCEPTED_POP(5).samples(1,:);
travelTime_values(:,2) = linkMap(1).lengthInMiles ./ ACCEPTED_POP(1).samples(1,:) + ...
    linkMap(3).lengthInMiles ./ ACCEPTED_POP(3).samples(1,:) + ...
    linkMap(5).lengthInMiles ./ ACCEPTED_POP(5).samples(1,:) + ...
    sensorMetaDataMap(400363).offsetMiles ./ ACCEPTED_POP(5).samples(1,:);

% calculate for t1 and t2
for i = 9:-2:5
    w(i,:) = ACCEPTED_POP(i).samples(1,:) .* ACCEPTED_POP(i).samples(2,:) ./...
        (ACCEPTED_POP(i).samples(2,:) - ACCEPTED_POP(i).samples(3,:));
end

travelTime_values(:,3) = linkMap(9).lengthInMiles ./ w(9,:) +...
    (linkMap(7).lengthInMiles - sensorMetaDataMap(400363).offsetMiles)./ w(7,:);
travelTime_values(:,4) = linkMap(9).lengthInMiles ./ w(9,:) +...
    linkMap(7).lengthInMiles ./ w(7,:) +...
    (linkMap(5).lengthInMiles - sensorMetaDataMap(400739).offsetMiles)./ w(5,:);
